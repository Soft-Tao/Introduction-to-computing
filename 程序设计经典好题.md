# 程序设计经典好题

**徐栩涛 2021/1/6**

***

[toc]

***

































## - 防雾霾

> 注意不能够简单的认为总污染数除以口罩的健康值就是口罩数，注意口罩的健康值一旦小于当天的污染程度，就需要更换。

| 描述                                                         |
| ------------------------------------------------------------ |
| 最近北京空气质量特别差，出门都要记得带防雾霾口罩哦。  但是口罩也不是永久有效的。假设一天的雾霾严重程度是a，口罩的健康度为m，一天后口罩的健康度就降低为m-a，==如果一天过去后口罩健康度小于等于0，那么第二天就需要换一个新的口罩。==  现在给出连续n天的雾霾严重程度，请你帮忙计算一下至少需要储备多少口罩才能度过这些天。`` |
| **关于输入**                                                 |
| 输入共两行 第一行两个整数n、m，分别表示连续的雾霾天数和口罩的初始健康度。(1<=n<=100,1<=m<=1000) 第二行n个整数a1,a2...an，ai表示第i天的雾霾严重程度。(1<=ai<=500)`` |
| **关于输出**                                                 |
| 输出共一行，即至少需要储备的口罩数量``                       |
| **例子输入**                                                 |
| `5 10 1 3 4 5 11`                                            |
| **例子输出**                                                 |
| `2`                                                          |

### 数组循环、条件判断、计数

```c
#include<stdio.h>

int main () {
   int a, b,num[100],sum=1,c; //sum初值为1，是因为最后一天不管口罩有没有报废，都要算一个，下面的循环只到了第a-1天，因为最后一天不再需要讨论
   scanf ("%d %d", &a,&b );
   for (int i=0;i<a;i++) scanf ("%d", &num[i]);
   c=b;  // b作为始终需要的一个值，不能随意改变，用c来引用
   for (int i=0;i<a-1;i++) {
       c=c-num[i];
       if (c<=0) {
           sum++; // 用的口罩数加一
           c = b; // 口罩健康值小于0，换一个口罩
       }
   }
   printf ("%d", sum);
}
```



## - 计数问题

> 注意看清题目，出现的含义是指在每个数的每一位上出现这个数字。

| 描述                                                         |
| ------------------------------------------------------------ |
| 试计算在区间 1 到 n 的所有整数中，数字 x(0 ≤ x ≤ 9)共出现了多少次？==例如，在 1 到 11 中，即在 1、2、3、4、5、6、7、8、9、10、11 中，数字 1 出现了 4 次，数字2出现了1次。==`` |
| **关于输入**                                                 |
| 输入共 1 行，包含 2 个整数 n、x，之间用一个空格隔开。``      |
| **关于输出**                                                 |
| 输出共 1 行，包含一个整数，表示 x 出现的次数。``             |
| **例子输入**                                                 |
| `11 1`                                                       |
| **例子输出**                                                 |
| `4`                                                          |
| **提示**                                                     |
| 对于所有的数据，1≤ n ≤ 10000，0≤ x ≤ 9。                     |

### 循环、对整形数各位数字的处理、计数

```c
#include<stdio.h>

int main () {
    int n,x,flag=0,c;  //flag作为计数指标
    scanf ("%d%d", &n,&x);
    for (int i = 1;i<=n;i++) {
        c = i;  // 同样，i作为循环变量，如果要进行处理，应该用另外一个数来引用
        while (c)
        {
            if ( (c-x)%10 == 0)  // 从c的个位数开始看，如果c-x是10的倍数，则c的个位就是x
            {
                flag++;
            }
            c = c/10; // 去除c的最后一位，将下一位作为个位
        }
    }
    printf ("%d", flag);
    return 0;
}
```



## - 终极大奖

> 审题，从第一号开始计数，不要忽略了第一次操作，如果有一个人出局了，要接着从下一个人开始报数。

| 描述                                                         |
| ------------------------------------------------------------ |
| 有n个人参与抽奖，然而他们的机会并不均等，这些人按顺时针方向围成一圈（编号1到n），从第1号开始报数，一直数到m，数到m的人失去一次抽奖的机会，==再接着==从1开始报数。当一个人的机会为0时，==不再参与抽奖==，就这样，直到圈内只剩下一个人，这个人将获得终极大奖。`` |
| **关于输入**                                                 |
| 输入有多组，每组有有2行，第一行输入两个整数n、m，分别代表参与抽奖的人数和每次数数数到几。 第二行输入n个整数，代表由编号1到n对应的每个人拥有的机会数量。  当n和m输入均为0时，结束输入。 1<=n<=100,1<=m<=100`` |
| **关于输出**                                                 |
| 输出有多行，按输入顺序，每行为对应组中获得终极大奖的人的编号。 |

### 直线排列的数组如何循环移动取值、退出循环的条件、游戏规则的正确解读、不确定行输入时输入的中止

```c
#include<stdio.h>

int main ()
{
    int n,m,i,p,flag=0,j=0;
    int num[101];
    int OUT[50];
    scanf ("%d%d", &n,&m);
    while (n != 0)    // 输入中止的条件，m或者n为0
    {
        for (i=0;i<n;i++)
        {
            scanf ("%d", &num[i]);
        }
        p = m%n-1;  // p为指标，后续的操作围绕指标的位置进行，首先要找到第一个中奖的人，要考虑到m有可能比n大
        num[p]--;
        if (num[p] == 0) flag++;// flag作为统计出局人数的指标，用于退出循环
        while (1)
        {
            if (flag == n-1) break; // n-1个人都出局了，则退出
            for (i=0;i<m;i++) // p应该继续寻找未出局的玩家，找m次
            {
                while (num[(p+1)%n] == 0) // 如果“下一个人”已经出局，这次移动不作数
                {
                    p = (p+1)%n;
                } // 直到下一个人是非0的
                p = (p+1)%n;//移到这个非0的人处
            }
            num[p]--; 
            if (num[p] == 0) flag++;
        } // 跳出循环后，p应该移动到唯一的那个非0的人处
        while (num[(p+1)%n] == 0)
        {
            p = (p+1)%n;
        }
        p = (p+1)%n;
        OUT[j] = p+1;  // 注意编号和数组的标号有1的差别
        j++;
        scanf ("%d%d", &n,&m); // 扫入下一组数据
        flag =0;
    }
    for (i=0;i<j;i++)
    {
        printf ("%d\n", OUT[i]);
    }
    return 0;
}

```



## - 寻找最长公共前缀

> 什么是不输出内容，可能包含空格的字符串最好不用`scanf`函数处理，建立数组时总是要比字符串长度多出一个字节。

| 描述                                                         |
| ------------------------------------------------------------ |
| 请从4个字符串中找出最长的公共前缀。``                        |
| **关于输入**                                                 |
| 输入有4行。每行输入是一个字符串==（可能包含空格）==，长度不超过==255个==字符。`` |
| **关于输出**                                                 |
| 所有输入字符串的公共前缀。如果没有公共前缀，则程序==不输出内容==。`` |
| **例子输入**                                                 |
| `Asdfcsdk Asddf Asdtes Asdtexd`                              |
| **例子输出**                                                 |
| `Asd`                                                        |

### 用`getchar`处理字符串、二维字符数组、越界的问题

```c
#include<stdio.h>
#include<string.h>

int main () {
    char str[4][256]; // 多预留一个字节用于储存'\n'
    int i,j,k=0;
    for (i=0;i<4;i++) {
        j=0;
        while ((str[i][j] = getchar()) != '\n') {
            j++;  //用getchar存入一行字符串的方法
        }
    }
    while (str[0][k] == str[1][k] && str[2][k] == str[1][k] && str[2][k] == str[3][k]) {
        k++; // k表示公共的长度
    }
    for (i=0;i<k;i++) { // 已经考虑到无输出的情况
        printf ("%c", str[0][i]); // 由于公共字符串一定是所有字符串的子串，选取一即可
    }
    return 0;
}
```



## - 购买礼物

> 注意到优先级不能相同，并且区别于口罩的问题，只有当剩余的钱大于等于要购买礼物的价格的时候，计数器才会加一

| 描述                                                         |
| ------------------------------------------------------------ |
| 要过新年了，小明想给许多同学购买礼物，选好礼物结账时发现带的钱不够，所以只能选择留下一部分。 每个要送礼物的同学在他心中有个优先级，小明决定优先级最大的优先购买，他为每个人挑选的礼物价格不同，下面请你算出小明能给多少人买到礼物。`` |
| **关于输入**                                                 |
| 输入有N+1行，第一行两个数字，选的礼物总数N和带的钱的总数M，后面N行每行包含两个数字，第一个数字表示礼物的价格P，第二个数字表示这个礼物要送的人在他心中的优先级L，==越大越优先购买，优先级不能相同==（N<100 M<1000 P<100 L<200  N,M,P,L均为整数）`` |
| **关于输出**                                                 |
| 输出一行，能买的礼物个数``                                   |
| **例子输入**                                                 |
| `5 10 2 4 6 3 1 5 7 2 1 1`                                   |
| **例子输出**                                                 |
| `3`                                                          |
| **提示**                                                     |
| 若优先级最高的礼物价格超出带的钱总数，视为不能购买任何礼物==（优先级较高的人没有，则不会考虑给优先级低的买）== |

### 在没有排序的情况下依次从大到小取出数、循环、条件判断（注意计数的问题）

```c
#include<stdio.h>

int main () {
    int n,m,i,q,count =0,flag;
    int num[101][2];
    scanf ("%d%d", &n,&m);
    for (i=0;i<n;i++) {
        scanf ("%d%d", &num[i][0],&num[i][1]);
    }
    while (1) { // 需要找到一个办法退出循环
        q=0;
        flag = 0;
        for (i=0;i<n;i++) {
            if (num[i][1] > num[q][1]) q = i; // q是优先级最大的指标
            if (num[i][1] >= 0) flag = 1; // 如果flag等于1，则说明还有同学的礼物没有买
        }
        if (flag == 0) break; // 都买完了，退出
        if (m >= num[q][0]) 
        {
            m = m - num[q][0]; // 买了一个礼物
            num[q][1] = -1; // 优先级处理成-1，因为它已经被买了
            count++;
        }
        else break; // 买不起了。退出
    }
    printf ("%d\n", count);
    return 0;
}
```



## - 基因编辑

> 最应当注意的是，对于片段`GTTTTT`进行依次修改时，第一次变成`GGTTTT`，此时中间虽然存在`GT`序列，但是不算。

| 描述                                                         |
| ------------------------------------------------------------ |
| 脱氧核糖核酸由两条互补的碱基链以双螺旋的方式结合而成，而构成DNA的碱基共有4种，分别为腺瞟呤（A）、鸟嘌呤（G）、胸腺嘧啶（T）和胞嘧啶（C）。  人类的性状就是由这些碱基组成的基因片段，转录表达的。先已知鸟嘌呤（G）、胸腺嘧啶（T）组成的基因片段GT会出现某种缺陷性状，现只考虑其中的一条碱基链，利用基因编辑技术==将GT片段 改造为GG==，以弥补基因缺陷。`` |
| **关于输入**                                                 |
| 一个字符串，表示一条碱基链。这个字符串只含有大写字母A、T、G、C，分别表示腺瞟呤、胸腺嘧啶、鸟嘌呤和胞嘧啶。字符串长度不超过255。`` |
| **关于输出**                                                 |
| 一个将输入的字符串中所有的GT片段编辑为GG片段的字符串。``     |
| **例子输入**                                                 |
| `ATATGGATGGTGTTTGGCTCTG`                                     |
| **例子输出**                                                 |
| `ATATGGATGGGGGTTGGCTCTG`                                     |

### 字符串的读取、字串的匹配、修改后的处理

```c
#include<stdio.h>

int main () {
    int i=0;
    char str[256]; //预留空位
    while ((str[i] = getchar())!='\n') i ++; // 读取
    for (i=0;str[i] != '\n';i++) { // 字符串长度不定的时候，循环的依据就是字符不为'\n'
        if (str[i] == 'G' && str[i+1] == 'T') // 匹配
        {
            str[i+1] = 'G';
            i++;  // 为了避免出现之前提到的情况，额外多移动一位
        }
    }
    for (i=0;str[i] != '\n';i++) printf ("%c", str[i]);
    return 0;
}
```



## - 筛选病人

> 有两次排序，不能简单的认为两次排序可以相互独立，先后进行，排序也有优先级。

| 描述                                                         |
| ------------------------------------------------------------ |
| 季节交替的时候是过敏性鼻炎的高发期，有很多人会出现过敏性鼻炎的症状。为了更好地进行分流治疗，医院在挂号时要求对病人的体温和打喷嚏情况进行检查，对于体温超过37.5度（含等于37.5度）并且打喷嚏的病人  初步判定为过敏性鼻炎（初筛）。现需要统计某天前来挂号就诊的病人中有多少人被初筛为过敏性鼻炎的病人。`` |
| **关于输入**                                                 |
| 第一行是某天前来挂号就诊的病人数n。（n < 200） 其后有n行，每行是病人的信息，包括四个信息： 姓名（字符串，不含空格，最多8个字符,每个人姓名的首字母都不相同）、年龄（int）、体温（float）、是否打喷嚏（整数，1表示打喷嚏，0表示不打喷嚏）。每行四个信息之间以一个空格分开。`` |
| **关于输出**                                                 |
| 输出所有被初步筛选为过敏性鼻炎的病人的以下三个信息，包括姓名、年龄、体温。每个信息中间用空格隔开。==要求是按照年龄从大到小的顺序输出，如果年龄相同，则按姓名首个字符的字典序输出。==`` |
| **例子输入**                                                 |
| `5 Zhang 54 38.3 0 Li 20 37.5 1 Wang 32 37.1 1 Zhao 66 39.0 1 Liu 26 38.2 1` |
| **例子输出**                                                 |
| `Zhao 66 39 Liu 26 38.2 Li 20 37.5`   ==39==                 |

### 结构数组、条件判断、字典序、起泡排序某种情况下于直接选择排序的优越性、整数输出不要小数点

```c

#include<stdio.h>
#include<string.h>

struct person
{
    char name[10];
    int age;
    float c;
    int f;
} ;  // 再次注意数组声明的语法
int main ()
{
    struct person patient [200];
    struct person p1 [201];
    int n,i,k=0,q,j,m,p,work;
    scanf ("%d", &n);
    for (i=0;i<n;i++) 
    {
        scanf ("%s", patient[i].name); // 用结构内字符数组储存字符串
        scanf ("%d%f%d", &patient[i].age,&patient[i].c, &patient[i].f);
        if (patient[i].c >= 37.5 && patient[i].f == 1)  // 满足条件的病人存入另一个结构数组中
        {
            p1[k] = patient[i];
            k++; // 用k作为计数指标
        }
    }
    
    for (j=1;j<k;j++) // 整体框架是起泡排序，相对于直接选择排序，在双条件下有明显的优势，直接选择可能不知道到底哪一个是“最小的”
    {
        work = 0;
        for (i=0;i<k-1;i++)
        {
            if ( (p1[i].age < p1[i+1].age)  || (p1[i].age == p1[i+1].age && (strcmp (p1[i].name, p1[i+1].name)) > 0) ) // 两个优先级有别的指标排序，只有在年龄相同的情况下才需要按照姓名排序，字符串比较最好使用strcmp
            {
                p1[200] = p1[i];
                p1[i] = p1[i+1];
                p1[i+1] = p1[200];
                work = 1;
            }
        }
        if (work == 0) break;
    }


    for (i=0;i<k;i++)
    {
        printf ("%s %d %g", p1[i].name, p1[i].age, p1[i].c); // '%g'可以使浮点数按照最小的长度输出
        printf ("\n");
    }
    return 0;
}
```

